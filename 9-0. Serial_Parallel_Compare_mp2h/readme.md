# ECE 220 Honor
# MP2 Parallel Accumulator with shared total

In this MP you will implement a parallel accumulator that calculates the sum of all numbers within a set of given files.

General guidelines: 
1. Do not change thread_info.h as this file is automatically generated and used for graph functionality
2. You can vary the number of threads used in acc.h
3. Do not change any of the python (.py) files
4. Use Applications -> System Tools -> Mate System Monitor -> Resources -> CPU History to see how CPU  responds to spawning multiple threads


Usage:  

  1. generate 1,000,000 input data points separated in [number_of_threads] files  
    
    $ python generate_data.py [number_of_threads]
    
  2. compile program
    
    $ gcc acc_serial.c -g -o acc_serial
    $ gcc acc_parallel.c -g -lpthread -o acc_parallel

  3. run test program

    $ ./acc_serial
    $ ./acc_parallel

  4. automatically recompile and run both versions of the accumulator, compares the output and speedup

    $ python benchmark.py

  5. make a graph of speedup vs number of threads used (requires matplotlib)

    $ python graph.py

Todos:  
  1. Complete the sequential accumulator helper function acc_file in acc.h  
  2. Complete the pthread wrapper function parallel_acc_wrapper in acc.h  
  3. Complete the sequential version in acc_serial.c  
  4. Complete the parallel version in acc_parallel.c
  5. Answers to question 6-8 should be submitted in "report.pdf"
  6. If we don't use `lock_for_result` in acc.h to guard result, will running `acc_parallel` multiple times gives you consistent results? Why?
  7. Include console output from running `python benchmark.py` with number_of_threads being 8.
  8. Include and compare graphs generated by `python graph.py` by both MP1 and MP2. Which solution is better and why?

